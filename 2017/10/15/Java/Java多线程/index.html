<!DOCTYPE HTML>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />
  
  <title>Java多线程 | 爱吃猫的鱼</title>
  <meta name="author" content="爱吃猫的鱼" />

  
  <meta name="description" content="进程与线程的区别：进程： 每一个进程都有独立的代码和数据空间(进程上下文)，进程间的切换有较大的开销，一个进程包含1-n个线程。进程是系统资源分配的最小单位。线程： 线程相对于进程更加轻量，上下文信息更少，创建和销毁更加简单。多个线程共享一个进程的资源，OS的许多资源分配和管理都是进程级别的，线程是OS调度的最小单位。
I/O密集性的场景适合使用多进程，计算密集型的场景适合多线程。" />
  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  <meta property="og:title" content="Java多线程" />
  <meta property="og:site_name" content="爱吃猫的鱼" />

  
  

  
    <meta property="og:image" content="" />
  

  
  <link href="/css/images/favicon.ico" rel="icon" />
  

  <link rel="alternate" href="/atom.xml" title="爱吃猫的鱼" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">爱吃猫的鱼</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/archives/">所有文章</a></li>
    
      <li><a href="/categories/编程感悟">编程感悟</a></li>
    
      <li><a href="/categories/算法">算法之道</a></li>
    
      <li><a href="/categories/Java">Java</a></li>
    
      <li><a href="/categories/Python">Python</a></li>
    
      <li><a href="/categories/Linux">Linux</a></li>
    
      <li><a href="/categories/机器学习">机器学习</a></li>
    
      <li><a href="/categories/技能树">Other</a></li>
    
      <li><a href="/categories/兴趣爱好">兴趣爱好</a></li>
    
      <li><a href="/categories/个人生活">我的生活</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2017-10-15T04:03:25.000Z"><a href="/2017/10/15/Java/Java多线程/">2017-10-15</a></time>
      
      
  
    <h1 class="title">Java多线程</h1>
  

    </header>
    <div class="entry">
      
        <p>进程与线程的区别：<br>进程： 每一个进程都有独立的代码和数据空间(进程上下文)，进程间的切换有较大的开销，一个进程包含1-n个线程。进程是系统资源分配的最小单位。<br>线程： 线程相对于进程更加轻量，上下文信息更少，创建和销毁更加简单。多个线程共享一个进程的资源，OS的许多资源分配和管理都是进程级别的，线程是OS调度的最小单位。</p>
<p>I/O密集性的场景适合使用多进程，计算密集型的场景适合多线程。<br><a id="more"></a><br>线程和进程的状态一样分为五个阶段：创建、销毁、运行、阻塞、终止</p>
<p>Java中实现多线程有两种方式：</p>
<ol>
<li>使用Thread类</li>
<li>实现Runable接口</li>
</ol>
<h2 id="一、扩展java-lang-Thread类"><a href="#一、扩展java-lang-Thread类" class="headerlink" title="一、扩展java.lang.Thread类"></a>一、扩展java.lang.Thread类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Thread1 extends Thread&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">            System.out.println(name + &quot;运行&quot; + i);</div><div class="line">            try &#123;</div><div class="line">                sleep((int) Math.random() * 10);</div><div class="line">            &#125;catch (InterruptedException e)&#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private String name;</div><div class="line">    public Thread1(String name)&#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Main&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Thread1 mTh1 = new Thread1(&quot;A&quot;);</div><div class="line">        Thread1 mth2 = new Thread1(&quot;B&quot;);</div><div class="line">        mTh1.start();</div><div class="line">        mth2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">A运行0</div><div class="line">B运行0</div><div class="line">B运行1</div><div class="line">A运行1</div><div class="line">A运行2</div><div class="line">B运行2</div><div class="line">A运行3</div><div class="line">B运行3</div><div class="line">A运行4</div><div class="line">B运行4</div><div class="line">A运行5</div><div class="line">B运行5</div><div class="line">A运行6</div><div class="line">B运行6</div><div class="line">A运行7</div><div class="line">B运行7</div><div class="line">A运行8</div><div class="line">B运行8</div><div class="line">B运行9</div><div class="line">A运行9</div></pre></td></tr></table></figure></p>
<p>从输出可以看出，多线程的运行时乱序的。start()方法被调用以后，线程并不是立马执行，而是转为runable状态，具体运行时间由操作系统决定。</p>
<h2 id="2-实现Java-lang-Runnable接口"><a href="#2-实现Java-lang-Runnable接口" class="headerlink" title="2. 实现Java.lang.Runnable接口"></a>2. 实现Java.lang.Runnable接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">class Thread2 implements Runnable&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">            System.out.println(name + &quot;运行:&quot; + i);</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep((int)Math.random() * 1);</div><div class="line">            &#125;catch (InterruptedException e)&#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private String name;</div><div class="line"></div><div class="line">    public Thread2(String name)&#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Main&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        new Thread(new Thread2(&quot;C&quot;)).start();</div><div class="line">        new Thread(new Thread2(&quot;D&quot;)).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">C运行:0</div><div class="line">D运行:0</div><div class="line">D运行:1</div><div class="line">C运行:1</div><div class="line">D运行:2</div><div class="line">C运行:2</div><div class="line">D运行:3</div><div class="line">C运行:3</div><div class="line">D运行:4</div><div class="line">C运行:4</div></pre></td></tr></table></figure></p>
<p>Thread2类通过实现Runnable()接口，使得类有了多线程属性。run()方法是多线程的一个约定，所有的多线程代码都在run()方法中。所有的多线程代码都是通过调用start()方法来运行，不管是扩展Thread还是实现Runnable接口。</p>
<h2 id="3-Thread和Runnable的区别"><a href="#3-Thread和Runnable的区别" class="headerlink" title="3. Thread和Runnable的区别"></a>3. Thread和Runnable的区别</h2><p>推荐使用Runnable的理由：</p>
<ol>
<li>适合多个相同的程序代码的线程去处理同一个资源；</li>
<li>可以避免Java中单继承的限制；</li>
<li>增加程序的健壮性，代码可以多个线程共享，代码和数据独立；</li>
<li>线程池的实现只能放入Runnable或callable类中，不能直接放入继承Thread类中。</li>
</ol>
<p>Runnable的意思就是“可执行”，Java语言中还有类似的接口例如Closeable接口，意思是“可以被关闭”。Runnable接口提供要求在实现类中去实现run()方法，Closeable接口要求实心close()。 </p>
<blockquote>
<blockquote>
<p>在Java程序中，所有的线程都是同时启动的，至于什么时候执行哪个线程得先看谁先得到CPU资源。每一个Java程序的运行，至少启动2个线程。一个是Main线程，另一个是垃圾回收线程。</p>
</blockquote>
</blockquote>
<h2 id="4-线程状态切换"><a href="#4-线程状态切换" class="headerlink" title="4. 线程状态切换"></a>4. 线程状态切换</h2><p>java.lang.Thread.State是一个枚举类，JDK8的源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public enum State &#123;</div><div class="line">    NEW,</div><div class="line">    RUNNABLE,</div><div class="line">    BLOCKED,</div><div class="line">    WAITING,</div><div class="line">    TIMED_WAITING,</div><div class="line">    TERMINATED;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<center><img src="http://yeshenlin.com/yelin_image/19.jpg" width="600"></center>



<ol>
<li>NEW： 创建一个Java外壳，没有真正的线程启动。就算调用start()方法也不代表状态立马改变。</li>
<li>RUNNABLE：线程对象创建后，其它线程调用了该线程状态的Start()方法。该状态的线程位于可运行线程池中，变得可运行，等待CPU调度；</li>
<li>RUNNING：就绪状态的线程获取了CPU，执行程序代码；</li>
<li>BLOCKED：线程被挂起。原因通常是它在等待一个“锁”，当某个synchronized正好有线程正在使用，一个贤臣尝试进入这个临界区，就会被阻塞，直到另一个线程执行wait()操作，才有机会去争夺临界区的权利；</li>
<li>WAITING：指一个线程拥有对象锁后进入到相应的代码区后，调用相应的”锁对象”的wait()操作后产生的一种结果；</li>
<li>TIMED_WAITING：使用某个时间资源作为锁对象，进而达到等待的目的，当时间达到时间触发线程回到工作RUNNABLE状态;</li>
<li>TREMINATED：run()方法走完了。</li>
</ol>
<p>BLOCKED和WAITING的关系和区别？<br>BLOCKED可以认为是虚拟机认为程序还不能进入临界区，因为同时进去就会有问题，这是一块临界区。WAITING的先决条件是进入到了临界区，也就是说线程已经拿到了“门票”，自己有可能已经进去做了一些事情，但此时通过判定某些业务参数，发现还有一些其他配合的资源没有准备充分，那么自己就等等再去做。<br>一个典型的案例就是通过wait()和notify()来完成生产消费者模型，当生产者生产过快，发现仓库满了，即消费者还没有把东西拿走（空位资源还没有准备好），生产者就稍微等一下再继续生产，即发出wait()告诉消费者有存货了，消费者拿走东西时会发出“有空位”的消息即notify()，那么生产者就开始工作了。</p>
<h2 id="5-线程调度"><a href="#5-线程调度" class="headerlink" title="5. 线程调度"></a>5. 线程调度</h2><p><strong>5.1 调整线程的优先级</strong></p>
<p>Java线程优先级取值1-10，Thread类中右三个静态变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static int MAX_PRIORITY //线程可以具有的最高优先级，取值为10</div><div class="line"></div><div class="line">static int MIN_PRIORITY //线程可以具有的最低优先级，取值为1</div><div class="line"></div><div class="line">static int NORM_PRIORITY //分配给线程默认的优先级，取值为5</div></pre></td></tr></table></figure></p>
<p>Thread类通过setPriority()和getPriority()方法分别用来设置和获取线程的优先级。线程的优先级具有传递性，创建线程和被创建线程具有相同的优先级。</p>
<p><strong>5.2 线程睡眠：</strong>Thread.sleep(long millis)方法，导致线程阻塞状态。睡眠时间结束，线程转为Runnable状态。<br><strong>5.3 线程等待：</strong>Object类中wait()方法，导致当前的线程等待，直到其它线程调用notify()/notifyAll()唤醒线程。<br><strong>5.4 线程让步：</strong>Thread.yield()方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。<br><strong>5.5 线程加入：</strong>Thread.join()方法，等待其它线程终止。在当前线程调用另一个线程的join()方法时，则当前线程转为阻塞状态，直到另一个线程运行，当前线程转为就绪状态。<br><strong>5.6 线程唤醒：</strong>Object类中的notify()方法，唤醒在此对象上等待的单个线程。如果有多个线程在等待，则选择任意的线程。线程通过调用其中任意一个wait()方法，在对象监视器上等待。直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规的方式与该对象上主动同步的其它所有主线程进行竞争；</p>
<h2 id="6-常用函数说明"><a href="#6-常用函数说明" class="headerlink" title="6. 常用函数说明"></a>6. 常用函数说明</h2><h3 id="6-1-sleep-long-milllis"><a href="#6-1-sleep-long-milllis" class="headerlink" title="6.1 sleep(long milllis)"></a>6.1 sleep(long milllis)</h3><p>在指定的毫秒数内让当前正在执行的线程休眠。</p>
<h3 id="6-2-join"><a href="#6-2-join" class="headerlink" title="6.2 join()"></a>6.2 join()</h3><p>该线程是指的主线程等待的子线程的终止，也就是在子线程调用了join()方法后的代码，只有等到子线程结束了才能执行.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Thread t = new Thread();</div><div class="line">t.strat(); t.join();</div></pre></td></tr></table></figure></p>
<p><strong>为什么使用join()？</strong><br>当主线程处理完其它事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完之后的结果，这个时候需要使用join()方法。</p>
<p>不使用join()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">class Thread1 extends Thread&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(Thread.currentThread().getName() + &quot;线程运行开始!&quot;);</div><div class="line">        for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">            System.out.println(&quot;子线程&quot; + name + &quot;運行：&quot;+ i);</div><div class="line">            try &#123;</div><div class="line">                sleep((int)Math.random() * 1);</div><div class="line">            &#125;catch (InterruptedException e)&#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(Thread.currentThread().getName() + &quot;线程运行结束！&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Thread1(String name)&#123;</div><div class="line">        super(name);</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private String name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Main&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        System.out.println(Thread.currentThread().getName() + &quot;主线程运行开始！&quot;);</div><div class="line">        Thread mTh1 = new Thread1(&quot;A&quot;);</div><div class="line">        Thread mTh2 = new Thread1(&quot;B&quot;);</div><div class="line">        mTh1.start();</div><div class="line">        mTh2.start();</div><div class="line">        System.out.println(Thread.currentThread().getName() + &quot;主线程运行结束！&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">main主线程运行开始！</div><div class="line">main主线程运行结束！</div><div class="line">B线程运行开始!</div><div class="line">A线程运行开始!</div><div class="line">子线程B運行：0</div><div class="line">子线程A運行：0</div><div class="line">子线程B運行：1</div><div class="line">子线程A運行：1</div><div class="line">子线程B運行：2</div><div class="line">子线程A運行：2</div><div class="line">子线程B運行：3</div><div class="line">子线程B運行：4</div><div class="line">子线程A運行：3</div><div class="line">B线程运行结束！</div><div class="line">子线程A運行：4</div><div class="line">A线程运行结束！</div></pre></td></tr></table></figure></p>
<p>使用join()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Main&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        System.out.println(Thread.currentThread().getName() + &quot;主线程运行开始！&quot;);</div><div class="line">        Thread mTh1 = new Thread1(&quot;A&quot;);</div><div class="line">        Thread mTh2 = new Thread1(&quot;B&quot;);</div><div class="line">        mTh1.start();</div><div class="line">        mTh2.start();</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            mTh1.join();</div><div class="line">        &#125;catch (InterruptedException e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            mTh2.join();</div><div class="line">        &#125;catch (InterruptedException e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(Thread.currentThread().getName() + &quot;主线程运行结束！&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">main主线程运行开始！</div><div class="line">A线程运行开始!</div><div class="line">B线程运行开始!</div><div class="line">子线程A運行：0</div><div class="line">子线程B運行：0</div><div class="line">子线程A運行：1</div><div class="line">子线程B運行：1</div><div class="line">子线程A運行：2</div><div class="line">子线程B運行：2</div><div class="line">子线程A運行：3</div><div class="line">子线程B運行：3</div><div class="line">子线程A運行：4</div><div class="line">子线程B運行：4</div><div class="line">A线程运行结束！</div><div class="line">B线程运行结束！</div><div class="line">main主线程运行结束！</div></pre></td></tr></table></figure></p>
<p>可以看出，主线程必须等待子线程先运行结束。<br>Join只是语法层面的线程合并，其实它更像是当前线程BLOCKEN状态时去等待其它线程结束的事件，而且是逐个去Join。</p>
<h3 id="6-3-yield"><a href="#6-3-yield" class="headerlink" title="6.3 yield()"></a>6.3 yield()</h3><p>暂停当前正在执行的线程，并执行其他线程。因此yield()的目的是让其它相同优先级的线程之前能适当的轮转执行。但是，实际中无法保证yield()达到让步，因为让步的线程还有可能被线程调度程序再次选中。<br>yield()并不是导致线程到等待/睡眠/阻塞状态，而是让线程回到可运行状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class ThreadYield extends Thread&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        for (int i = 0; i &lt; 50; i++) &#123;</div><div class="line">            System.out.println(&quot;&quot; + this.getName()+ &quot;------&quot; + i);</div><div class="line">            if (i ==30)&#123;</div><div class="line">                this.yield();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ThreadYield(String name)&#123;</div><div class="line">        super(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private String name;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Main&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ThreadYield yt1 = new ThreadYield(&quot;张三&quot;);</div><div class="line">        ThreadYield yt2 = new ThreadYield(&quot;李四&quot;);</div><div class="line">        yt1.start();</div><div class="line">        yt2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">第一种情况：</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">张三------29</div><div class="line">张三------30</div><div class="line">李四------0</div><div class="line">李四------1</div><div class="line">李四------2</div><div class="line">李四------3</div></pre></td></tr></table></figure>
<p>第二种情况：李四（线程）执行到30时会CPU时间让掉，这时李四(线程)抢到CPU时间并执行。</p>
<h3 id="6-4-sleep-和yield-区别"><a href="#6-4-sleep-和yield-区别" class="headerlink" title="6.4 sleep()和yield()区别"></a>6.4 sleep()和yield()区别</h3><ol>
<li>sleep()方法会使线程进入停止状态，在指定时间内不会再次执行；yield()方法使当前线程进入可执行状态，很有可能有马上又被执行。</li>
<li>sleep()方法使当前运行的线程停止一段时间，进入不可运行状态，这段时间是由程序来设定的。yield()方法使CPU让出CPU占有权，让出的时间是不可设定的。yield()执行后，先检测当前是否有相同的优先级处于可运行状态，如果有，则把CPU的占有权交给此线程，否则，继续运行原来的线程，所以yield()方法被称为”退让”。</li>
<li>sleep()方法允许较低优先级的线程获得再次运行的机会，但yield()方法执行时，当前线程仍然处于可运行状态，所以不可能让较低优先级的线程获得CPU的占有权。</li>
</ol>
<h3 id="6-5-setPriority"><a href="#6-5-setPriority" class="headerlink" title="6.5 setPriority()"></a>6.5 setPriority()</h3><p>更改线程优先级的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Thread4 t1 = new Thread(&quot;t1&quot;);</div><div class="line">Thread4 t2 = new Thread(&quot;t2&quot;);</div><div class="line"></div><div class="line">t1.setPriority(Thread.MAX_PRIORITY);</div><div class="line">t2.setPriority(Thread.MIN_PRIORITY);</div></pre></td></tr></table></figure></p>
<h3 id="6-6-interrupt"><a href="#6-6-interrupt" class="headerlink" title="6.6 interrupt()"></a>6.6 interrupt()</h3><p>不是中断某个线程！它只是线程发送一个中断信号，让线程在无线等待（如死锁）时能抛出，从而结束线程，但是如果你能吃掉这个异常，那么线程还是不会被中断的。</p>
<p>interrupt()操作在线程处于BLOCKEN状态时没用，在其他状态下都有效吗？<br>interrupt()操作对线程处于RUNNING状态时也没用，或者说只对处于WAITING和TIMED_WAITING状态的线程有用，让它们产生实质性的异常抛出。</p>
<h3 id="6-7-wait"><a href="#6-7-wait" class="headerlink" title="6.7 wait()"></a>6.7 wait()</h3><p>Obj.wait()与Obj.notify()必须要与synchronizd(Obj)一起使用，也就是wait与notify是针对已经获取Obj锁进行操作的，从语法角度来讲Obj.wait()与Obj.notify()必须在synchronized(Obj){…}语句块内。<br>从功能上来讲，wait()就是线程获取对象锁之后，同时本线程休眠。直到其它线程调用对象的notify()唤醒该线程。相应的notify()就是对对象锁的唤醒操作。但是有一点需要注意的是，notify()被调用后并不是立马释放对象锁的，而是在synchronized(){}语句执行结束，自动释放后，JVM会在wait()对象锁的线程中随机选取线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了线程间的同步、唤醒的操作。Thread.sleep()和Object.wait()都可以暂停当前线程，主要的区别是Obj.wait()在释放CPU时，释放对象锁的控制。<br>建立三个线程，A线程打印10次A，B线程打印10次B，C线程打印10次C，要求线程同时运行，交替打印ABC。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public class MyThreadPrinter2 implements Runnable&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        int count = 10;</div><div class="line">        while (count &gt; 0)&#123;</div><div class="line">            synchronized (prev)&#123;</div><div class="line">                synchronized (self)&#123;</div><div class="line">                    System.out.println(name);</div><div class="line">                    count--;</div><div class="line"></div><div class="line">                    self.notify();</div><div class="line">                &#125;</div><div class="line">                try &#123;</div><div class="line">                    prev.wait();</div><div class="line">                &#125;catch (InterruptedException e)&#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception&#123;</div><div class="line">        Object a = new Object();</div><div class="line">        Object b = new Object();</div><div class="line">        Object c = new Object();</div><div class="line">        MyThreadPrinter2 pa = new MyThreadPrinter2(&quot;A&quot;, c, a);</div><div class="line">        MyThreadPrinter2 pb = new MyThreadPrinter2(&quot;B&quot;, a, b);</div><div class="line">        MyThreadPrinter2 pc = new MyThreadPrinter2(&quot;C&quot;, b, c);</div><div class="line"></div><div class="line">        new Thread(pa).start();</div><div class="line">        Thread.sleep(100);  //確保按順序A,B,C執行</div><div class="line">        new Thread(pb).start();</div><div class="line">        Thread.sleep(100);</div><div class="line">        new Thread(pc).start();</div><div class="line">        Thread.sleep(100);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private MyThreadPrinter2(String name, Object prev, Object self)&#123;</div><div class="line">        this.name = name;</div><div class="line">        this.prev = prev;</div><div class="line">        this.self = self;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private String name;</div><div class="line">    private Object prev;</div><div class="line">    private Object self;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="6-8-wait-和sleep-的区别"><a href="#6-8-wait-和sleep-的区别" class="headerlink" title="6.8 wait()和sleep()的区别"></a>6.8 wait()和sleep()的区别</h3><p>共同点：</p>
<ol>
<li>在多线程的环境下，都可以在程序调用出指定阻塞的毫秒数，并返回；</li>
<li>wait()和sleep()都可以通过interrupt()方法，打断线程的暂停状态，从而使线程立刻抛出InterruptedException。如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻B正在wait/sleep/join，则线程B会立刻抛出InterruptException，在catch{}中直接return即可安全地结束线程；需要注意的是，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某些线程调用interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到wait()/sleep()/join()，就会立刻抛出InterruptedException。</li>
</ol>
<p>不同点：</p>
<ol>
<li>Thread类的方法：sleep(),yield()；Object的方法：wait()和notify()等。</li>
<li>每一个对象有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。sleep()方法没有释放锁，wait()方法释放了锁，使得其他线程可以使用同步控制块或者方法；</li>
<li>wait,notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep()可以在任何地方使用。</li>
</ol>
<p>所以sleep()和wait()方法最大的区别是：<br>sleep()睡眠时，保持对象锁，仍然占有该锁；<br>而wait()睡眠时，释放对象锁。<br>但是wait()和sleep()都可以interrupt()方法打断线程的暂停状态，从而使用线程立刻抛出InterruptedException。</p>
<h2 id="7-常见线程名字解释"><a href="#7-常见线程名字解释" class="headerlink" title="7. 常见线程名字解释"></a>7. 常见线程名字解释</h2><p>sleep():强迫一个线程睡眠N毫秒<br>isAlive()：判断一个线程是否存活<br>join()：等待线程终止<br>activeCount():程序中活跃的线程数<br>enumerate():枚举程序中的线程<br>currentThread():得到当前线程<br>isDaemon():一个线程是否为守护线程<br>setDaemon():设置一个守护线程<br>setName():强迫一个线程状态<br>notify():通知一个线程继续运行<br>setPriority():设置一个线程的优先级</p>
<h2 id="8-线程同步"><a href="#8-线程同步" class="headerlink" title="8. 线程同步"></a>8. 线程同步</h2><ol>
<li>synchronized关键字的作用域有两种：<ul>
<li>是某个对象实例内，synchronzied aMthod(){}可以防止多个线程同时访问这个对象的synchronized方法</li>
<li>在某个类的范围，synchronized static aStaticMethod{}防止多个线程同时访问这个类中的synchronized static方法。它可以对类的所有对象实例起作用。</li>
</ul>
</li>
<li>除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。用法是:synchronized(this),它的作用域是当前对象；</li>
<li>synchronized关键字是不能继承的</li>
</ol>
<h3 id="8-1-讨论synchronized用到不同的地方对代码产生的影响"><a href="#8-1-讨论synchronized用到不同的地方对代码产生的影响" class="headerlink" title="8.1 讨论synchronized用到不同的地方对代码产生的影响"></a>8.1 讨论synchronized用到不同的地方对代码产生的影响</h3><p>wait()和notify()的实现基础都是基于对象的，既然是基于对象的，因此它不得不用一个数据结构来存放这些等待的线程，而且这个数据结构应该是与该对象绑定的（双向链表）。在向这个对象锁对应的双向链表中写入、删除时，依然存在并发问题，理论上也需要一个锁来控制。JVM内核源码中并没有发现任何自己永锁来控制写入的动作，只是通过检查当前线程是否为对象的OWNER来判定是否要抛出相应的异常。<br>1、把synchronized做函数的修饰符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public synchronized void methodAAA()&#123;</div><div class="line">    this.wait();    //this.notify();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这就是同步方法，那这时synchronized锁定的是哪个对象呢？它锁定的是调用这个同步方法的对象。当一个对象在不同的线程中执行这个同步方法时，它们之间会形成互斥，达到同步的效果。但是这个对象所属的Class所产生的另一对象P2却可以任意调用这个被加了synchronized关键字的方法。</p>
<p>上面的示例代码等同于如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void methodAAA()&#123;</div><div class="line">    synchronized(this)&#123; //this指的是调用这个方法的对象，如P1。可见同步方法实质是将synchronized作用于object reference。一个拿到P1对象锁的线程，才可以调用P1的同步方法，而对P2而言，P1这个锁与它毫不相干。</div><div class="line">        //...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2、同步块，示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void method3(SomeObject so)&#123;</div><div class="line">    synchronized(so)&#123;</div><div class="line">        so.wait();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这时，锁就是so对象，谁拿到这个锁就可以运行它所控制的那段代码。当有一个明确的对象作为锁时，就可以这样写程序，但当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的instance变量来充当锁：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Foo implments Runnable&#123;</div><div class="line">    private byte[] lock = new byte[0];  //特殊的instance变量</div><div class="line">    public void methodA()&#123;</div><div class="line">        synchroized(object)&#123;</div><div class="line">            object.wait();    //object.notify();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3、将synchronized作用于static函数，示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Class Foo&#123;</div><div class="line">    public synchronized static void methodAAA()&#123;    //同步的static函数</div><div class="line">        //...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void methodBBB()&#123;</div><div class="line">        synichroized(Foo.class)     //class literal(类名称字面变量)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码中的method()方法是class literal作为锁的情况，它和同步的static函数产生的效果一样的，取得的锁很特别，是当前调用这个方法的对象所属的类。</p>
<h2 id="9-线程数据传递"><a href="#9-线程数据传递" class="headerlink" title="9. 线程数据传递"></a>9. 线程数据传递</h2><h3 id="9-1-通过构造函数传递数据"><a href="#9-1-通过构造函数传递数据" class="headerlink" title="9.1 通过构造函数传递数据"></a>9.1 通过构造函数传递数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class MyThread extends Thread&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Thread thread = new MyThread(&quot;world&quot;);</div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(&quot;hello&quot; + name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public MyThread(String name)&#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private String name;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用构造函数来传递数据虽然比较安全，但如果要传递的数据比较多时，就会造成很多的不便。</p>
<h3 id="9-2-通过变量和方法传递数据"><a href="#9-2-通过变量和方法传递数据" class="headerlink" title="9.2 通过变量和方法传递数据"></a>9.2 通过变量和方法传递数据</h3><p>向对象中传入数据一般有两次机会，第一次机会是在建立对象时通过构造方法将数据传入，另外一次机会就是在类中定义一系列的public的方法或变量。然后在建立完对象后，通过实例个赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class MyThread implements Runnable&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        MyThread myThread = new MyThread();</div><div class="line">        myThread.setName(&quot;world&quot;);</div><div class="line">        Thread thread = new Thread(myThread);</div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(&quot;hello&quot; + name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private String name;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="9-3-通过回调函数传递数据"><a href="#9-3-通过回调函数传递数据" class="headerlink" title="9.3 通过回调函数传递数据"></a>9.3 通过回调函数传递数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">class Data</div><div class="line">&#123;</div><div class="line">    public int value = 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Work</div><div class="line">&#123;</div><div class="line">    public void process(Data data, Integer[] numbers)</div><div class="line">    &#123;</div><div class="line">        for (int n : numbers)</div><div class="line">        &#123;</div><div class="line">            data.value += n;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class MyThread extends Thread</div><div class="line">&#123;</div><div class="line">    private Work work;</div><div class="line">    public MyThread(Work work)</div><div class="line">    &#123;</div><div class="line">        this.work = work;</div><div class="line">    &#125;</div><div class="line">    public void run()</div><div class="line">    &#123;</div><div class="line">        java.util.Random random = new java.util.Random();</div><div class="line">        Data data = new Data();</div><div class="line">        int n1 = random.nextInt(1000);</div><div class="line">        int n2 = random.nextInt(2000);</div><div class="line">        int n3 = random.nextInt(3000);</div><div class="line">        work.process(data, n1, n2, n3); // 使用回调函数</div><div class="line">        System.out.println(String.valueOf(n1) + &quot;+&quot; + String.valueOf(n2) + &quot;+&quot;</div><div class="line">                + String.valueOf(n3) + &quot;=&quot; + data.value);</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line">        Thread thread = new MyThread3(new Work());</div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol>
<li><a href="http://blog.csdn.net/evankaka/article/details/44153709" target="_blank" rel="external">Java多线程学习</a></li>
</ol>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/Java/">Java</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/Java/">Java</a>, <a href="/tags/多线程/">多线程</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/Java/">Java</a><small>7</small></li>
  
    <li><a href="/categories/Python/">Python</a><small>6</small></li>
  
    <li><a href="/categories/个人生活/">个人生活</a><small>8</small></li>
  
    <li><a href="/categories/兴趣爱好/">兴趣爱好</a><small>5</small></li>
  
    <li><a href="/categories/技能树/">技能树</a><small>2</small></li>
  
    <li><a href="/categories/算法/">算法</a><small>11</small></li>
  
    <li><a href="/categories/编程感悟/">编程感悟</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2018/01/31/文章/《大路》书摘/">《大路》书摘</a>
      </li>
    
      <li>
        <a href="/2018/01/12/算法/每日一道算法题/字符串查找/">字符串查找</a>
      </li>
    
      <li>
        <a href="/2018/01/12/Python/Python API备忘/">python API 备忘</a>
      </li>
    
      <li>
        <a href="/2017/12/26/日记/听见/">听见</a>
      </li>
    
      <li>
        <a href="/2017/11/25/Python/Python核心编程第一章/">《Python核心编程》第一章习题-正则表达式</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/BFS/">BFS</a><small>1</small></li>
  
    <li><a href="/tags/DP/">DP</a><small>4</small></li>
  
    <li><a href="/tags/JVM/">JVM</a><small>3</small></li>
  
    <li><a href="/tags/Java/">Java</a><small>5</small></li>
  
    <li><a href="/tags/Python/">Python</a><small>4</small></li>
  
    <li><a href="/tags/Str/">Str</a><small>1</small></li>
  
    <li><a href="/tags/coding/">coding</a><small>1</small></li>
  
    <li><a href="/tags/docker/">docker</a><small>1</small></li>
  
    <li><a href="/tags/string/">string</a><small>1</small></li>
  
    <li><a href="/tags/三毛/">三毛</a><small>1</small></li>
  
    <li><a href="/tags/切片/">切片</a><small>1</small></li>
  
    <li><a href="/tags/列表生成式/">列表生成式</a><small>1</small></li>
  
    <li><a href="/tags/多线程/">多线程</a><small>1</small></li>
  
    <li><a href="/tags/字符串/">字符串</a><small>2</small></li>
  
    <li><a href="/tags/张若水/">张若水</a><small>1</small></li>
  
    <li><a href="/tags/徐志摩/">徐志摩</a><small>1</small></li>
  
    <li><a href="/tags/所线程/">所线程</a><small>1</small></li>
  
    <li><a href="/tags/排序/">排序</a><small>1</small></li>
  
    <li><a href="/tags/数据库/">数据库</a><small>1</small></li>
  
    <li><a href="/tags/日记/">日记</a><small>5</small></li>
  
    <li><a href="/tags/杨绛/">杨绛</a><small>1</small></li>
  
    <li><a href="/tags/正则表达式/">正则表达式</a><small>1</small></li>
  
    <li><a href="/tags/深拷贝/">深拷贝</a><small>1</small></li>
  
    <li><a href="/tags/生成器/">生成器</a><small>1</small></li>
  
    <li><a href="/tags/生活/">生活</a><small>2</small></li>
  
    <li><a href="/tags/网课/">网课</a><small>1</small></li>
  
    <li><a href="/tags/美食/">美食</a><small>1</small></li>
  
    <li><a href="/tags/读书/">读书</a><small>1</small></li>
  
    <li><a href="/tags/迭代/">迭代</a><small>1</small></li>
  
    <li><a href="/tags/链接/">链接</a><small>1</small></li>
  
    <li><a href="/tags/链表/">链表</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/BFS/" style="font-size: 10px;">BFS</a> <a href="/tags/DP/" style="font-size: 17.5px;">DP</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Python/" style="font-size: 17.5px;">Python</a> <a href="/tags/Str/" style="font-size: 10px;">Str</a> <a href="/tags/coding/" style="font-size: 10px;">coding</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/string/" style="font-size: 10px;">string</a> <a href="/tags/三毛/" style="font-size: 10px;">三毛</a> <a href="/tags/切片/" style="font-size: 10px;">切片</a> <a href="/tags/列表生成式/" style="font-size: 10px;">列表生成式</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/字符串/" style="font-size: 12.5px;">字符串</a> <a href="/tags/张若水/" style="font-size: 10px;">张若水</a> <a href="/tags/徐志摩/" style="font-size: 10px;">徐志摩</a> <a href="/tags/所线程/" style="font-size: 10px;">所线程</a> <a href="/tags/排序/" style="font-size: 10px;">排序</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/日记/" style="font-size: 20px;">日记</a> <a href="/tags/杨绛/" style="font-size: 10px;">杨绛</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/深拷贝/" style="font-size: 10px;">深拷贝</a> <a href="/tags/生成器/" style="font-size: 10px;">生成器</a> <a href="/tags/生活/" style="font-size: 12.5px;">生活</a> <a href="/tags/网课/" style="font-size: 10px;">网课</a> <a href="/tags/美食/" style="font-size: 10px;">美食</a> <a href="/tags/读书/" style="font-size: 10px;">读书</a> <a href="/tags/迭代/" style="font-size: 10px;">迭代</a> <a href="/tags/链接/" style="font-size: 10px;">链接</a> <a href="/tags/链表/" style="font-size: 10px;">链表</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2018 爱吃猫的鱼
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id='bg'></div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>